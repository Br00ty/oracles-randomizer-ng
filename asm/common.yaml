defines:
  # constants
  COLLECT_PICKUP_ALT: 0x02
  COLLECT_PICKUP: 0x0a
  COLLECT_POOF: 0x1a
  COLLECT_FALL_KEY: 0x28
  COLLECT_FALL: 0x29
  COLLECT_CHEST: 0x38
  COLLECT_DIVE: 0x49
  COLLECT_CHEST_MAP_OR_COMPASS: 0x68
  TREASURE_SHIELD: 0x01
  TREASURE_SWORD: 0x05
  TREASURE_BOOMERANG: 0x06
  TREASURE_SLINGSHOT: 0x13
  TREASURE_FEATHER: 0x17
  TREASURE_SEED_SATCHEL: 0x19
  TREASURE_GALE_SEEDS: 0x23
  DEV_RING: 0x40

  # wram
  wKeysPressed: 0xc481
  wAnimalRegion: 0xc610
  wRingsObtained: 0xc616
  wInventoryB: 0xc688
  wMapMenu_mode: 0xcbb3
  wMapMenu_cursorIndex: 0xcbb6
  wInventorySubmenu1CursorPos: 0xcbd1
  wRingMenu_mode: 0xcbd3
  wIsLinkedGame: 0xcc01
  wScreenOffsetY: 0xcd08
  w1Link.angle: 0xd009

  # rom 00
  interBankCall: 0x008a
  setFlag: 0x020e
  decHlRef16WithCap: 0x0237

banks:
  0x00:
  # don't play any music. should only be called if the -nomusic flag is
  # given.
  - filterMusic: |
      ld h,a
      cp a,49
      jr nc,.sfx
      ld a,08
      ret
      .sfx
      ld a,(ff00+hMusicVar)
      ret

  # return z iff the current group and room match c and b.
  - compareRoom: |
      ld a,(wActiveGroup)
      cp c
      ret nz
      ld a,(wActiveRoom)
      cp b
      ret

  # searches for a value in a table starting at hl, with an entry matching
  # keys b and subkey c, and values e bytes long. sets c if found. a key of
  # ff ends the table.
  - searchDoubleKey: |
      .loop
      ldi a,(hl)
      cp a,ff
      ret z
      cp b
      jr nz,.next
      ldi a,(hl)
      cp c
      jr nz,.done
      scf
      ret
      .next
      inc hl
      .done
      ld a,e
      rst 10
      jr .loop

  # calls lookupCollectMode_body in another bank.
  - lookupCollectMode: |
      push bc
      push de
      push hl
      ld e,06
      ld hl,lookupCollectMode_body
      call interBankCall
      ld a,e
      pop hl
      cp a,ff
      jr nz,.next
      dec hl
      ldi a,(hl)
      .next
      pop de
      pop bc
      ret

  0x02:
  # warp to room under cursor if using tree warp with developer ring.
  - devWarp: |
      ld a,(wActiveRing)
      cp a,DEV_RING
      jr nz,.noWarp
      ld a,(wActiveGroup)
      cp a,02
      jr nc,.noWarp
      or a,80
      ld (wWarpDestGroup),a
      ld a,(wMapMenu_cursorIndex)
      ld (wWarpDestIndex),a
      .noWarp
      ld a,03
      call setMusicVolume
      ret

  # allow ring list to be accessed through the ring box icon.
  - openRingList: |
      ld a,(wInventorySubmenu1CursorPos)
      cp a,0f
      ret nz
      ld a,81
      ld (wRingMenu_mode),a
      ld a,04
      call openMenu
      pop hl
      ret

  # auto-equip rings when selected in ring list.
  - autoEquipRing: |
      call _ringMenu_updateSelectedRingFromList
      ld (wActiveRing),a
      ret

  # don't save gfx when opening ring list from subscreen (they were already
  # saved when opening the item menu), and clear screen scroll variables (which
  # are saved anyway).
  - ringListGfxFix: |
      call setMusicVolume
      ld a,(wRingMenu_mode)
      bit 7,a
      ret z
      and a,7f
      ld (wRingMenu_mode),a
      xor a
      ld (ff00+hCameraY),a
      ld (ff00+hCameraX),a
      ld hl,wScreenOffsetY
      ldi (hl),a
      ldi (hl),a
      jp clearMenu

  # always treat starting seed tree as visited for warping purposes.
  - checkCursorVisited: |
      ld a,(wMapMenu_cursorIndex)
  - checkTreeVisited: |
      cp a,STARTING_TREE_MAP_INDEX
      jp nz,_mapMenu_checkRoomVisited
      or a
      ret

  0x03:
  # allow skipping the capcom screen after one second by pressing start.
  - skipCapcom: |
      push hl
      ld a,(cbb3)
      cp a,94
      jr nc,.noSkip
      call forceEnableIntroInputs
      .noSkip
      pop hl
      jp decHlRef16WithCap

  0x04:
  # look up tiles in custom replacement table after loading a room. the format
  # is (group, room, bitmask, YX, tile ID), with ff ending the table. if the
  # bitmask AND the current room flags is nonzero, the replacement is not made.
  - applyExtraTileSubstitutions: |
      push bc
      push de
      call getThisRoomFlags
      ld e,a
      ld hl,tileSubTable
      ld a,(wActiveGroup)
      ld b,a
      ld a,(wActiveRoom)
      ld c,a
      .loop
      ldi a,(hl)
      cp a,ff
      jr z,.done
      cp b
      jr nz,.groupMismatch
      ldi a,(hl)
      cp c
      jr nz,.roomMismatch
      ldi a,(hl)
      and e
      jr nz,.flagMismatch
      push de
      ld d,cf
      ldi a,(hl)
      ld e,a
      ldi a,(hl)
      ld (de),a
      pop de
      jr .loop
      .groupMismatch
      inc hl
      .roomMismatch
      inc hl
      .flagMismatch
      inc hl
      inc hl
      jr .loop
      .done
      pop de
      pop bc
      call applyAllTileSubstitutions
      ret

  0x05:
  # if wearing dev ring, jump over any tile like a ledge by pressing B with no
  # B item equipped.
  - devJump: |
      push af
      ld a,(wActiveRing)
      cp a,DEV_RING
      jr nz,.next
      ld a,(wInventoryB)
      or a
      jr nz,.next
      ld a,(wKeysPressed)
      and a,02
      jr z,.next
      pop af
      ld a,(w1Link.angle)
      scf
      ret
      .next
      pop af
      ret

  0x06:
  # return a spawning item's collection mode in a and e, based on current room.
  # the table format is (group, room, mode), and modes 80+ are used to index a
  # jump table for special cases. if no match is found, it returns the regular,
  # non-overriden mode.
  - lookupCollectMode_body: |
      ld a,(wActiveGroup)
      ld b,a
      ld a,(wActiveRoom)
      ld c,a
      ld e,01
      ld hl,collectModeTable
      call searchDoubleKey
      ld e,a
      ret nc
      ld a,(hl)
      ld e,a
      cp a,80
      ret c
      ld hl,collectSpecialJumpTable
      and a,7f
      add a,a
      rst 10
      ldi a,(hl)
      ld h,(hl)
      ld l,a
      jp (hl)

  0x3f:
  # put obtained rings directly into ring list (no need for appraisal), and
  # tell the player what type of ring it is.
  - autoAppraiseRing: |
      ld hl,wRingsObtained
      ld a,c
      and a,3f
      call setFlag
      ld a,c
      add a,40
      ld (cbb1),a # part of wTextSubstitutions
      ld bc,301c
      call showText
      ret

  # use different seed capacity table, so that level zero satchel can still
  # hold 20 seeds.
  - seedCapacityTable: |
      db 20,20,50,99
