defines:
  # constants
  AREAFLAG_OUTDOORS: 0x01
  COLLECT_PICKUP_ALT: 0x02
  COLLECT_PICKUP: 0x0a
  COLLECT_POOF: 0x1a
  COLLECT_FALL_KEY: 0x28
  COLLECT_FALL: 0x29
  COLLECT_CHEST_NOFLAG: 0x30
  COLLECT_CHEST: 0x38
  COLLECT_DIVE: 0x49
  COLLECT_CHEST_MAP_OR_COMPASS: 0x68
  SND_GETITEM: 0x4c
  SND_CLINK: 0x50
  SND_ERROR: 0x5a
  SND_SOLVEPUZZLE_2: 0x5b
  TREASURE_SHIELD: 0x01
  TREASURE_PUNCH: 0x02
  TREASURE_CANE_OF_SOMARIA: 0x04
  TREASURE_SWORD: 0x05
  TREASURE_BOOMERANG: 0x06
  TREASURE_ROD_OF_SEASONS: 0x07
  TREASURE_MAGNET_GLOVES: 0x08
  TREASURE_FLUTE: 0x0e
  TREASURE_SHOOTER: 0x0f
  TREASURE_SLINGSHOT: 0x13
  TREASURE_FEATHER: 0x17
  TREASURE_SEED_SATCHEL: 0x19
  TREASURE_FOOLS_ORE: 0x1e
  TREASURE_GALE_SEEDS: 0x23
  TREASURE_MYSTERY_SEEDS: 0x24
  TREASURE_TUNE_OF_ECHOES: 0x25
  TREASURE_TUNE_OF_CURRENTS: 0x26
  TREASURE_HEART_CONTAINER: 0x2a
  TREASURE_RING: 0x2d
  TREASURE_FLIPPERS: 0x2e
  TREASURE_BOSS_KEY: 0x31
  TREASURE_MAKU_SEED: 0x36
  TREASURE_ESSENCE: 0x40
  TREASURE_STAR_ORE: 0x45
  TREASURE_GORON_LETTER: 0x59
  DEV_RING: 0x40

  # script commands
  scriptend: 0x00
  loadscript: 0x83
  jumptable_memoryaddress: 0x87
  setanimation: 0x8f
  writememory: 0x91
  ormemory: 0x92
  rungenericnpc: 0x97
  showtext: 0x98
  checkabutton: 0x9e
  checkcfc0_bit0: 0xa0
  jumpifroomflagset: 0xb0
  orroomflag: 0xb1
  jumpifc6xxset: 0xb3
  writec6xx: 0xb4
  setglobalflag: 0xb6
  setdisabledobjectsto00: 0xb9
  setdisabledobjectsto11: 0xba
  disableinput: 0xbd
  enableinput: 0xbe
  callscript: 0xc0
  retscript: 0xc1
  jumpalways: 0xc4
  jumpifmemoryset: 0xc7
  jumpifmemoryeq: 0xcb
  checkcollidedwithlink_onground: 0xd0
  setcounter1: 0xd7
  spawnitem: 0xdd
  giveitem: 0xde
  jumpifitemobtained: 0xdf
  asm15: 0xe0
  initcollisions: 0xeb
  movedown: 0xee
  delay30frames: 0xf6

  # hram
  hRomBank: 0x97

  # wram
  wKeysPressed: 0xc481
  wAnimalRegion: 0xc610
  wRingsObtained: 0xc616
  wTotalSignsDestroyed: 0xc626
  wInventoryB: 0xc688
  wTextIndexL: 0xcba2
  wTextIndexH: 0xcba3
  wMapMenu_mode: 0xcbb3
  wMapMenu_cursorIndex: 0xcbb6
  wInventorySubmenu1CursorPos: 0xcbd1
  wRingMenu_mode: 0xcbd3
  wIsLinkedGame: 0xcc01
  wMenuDisabled: 0xcc02
  wCutsceneState: 0xcc03
  wCutsceneTrigger: 0xcc04
  wScreenOffsetY: 0xcd08
  wScreenShakeCounterY: 0xcd18
  w1Link.angle: 0xd009
  w1Link.yh: 0xd00b
  w1Link.xh: 0xd00d
  w7ActiveBank: 0xd0d4

  # rom 00
  interBankCall: 0x008a
  setFlag: 0x020e
  getNumSetBits: 0x0176
  compareHlToBc: 0x01d6
  decHlRef16WithCap: 0x0237

  # rom 3f
  _interactionGetData: 0x4437
  giveTreasure_body: 0x44c8

appends:
  0x00:
  # don't play any music. should only be called if the -nomusic flag is
  # given.
  - filterMusic: |
      ld h,a
      cp a,49
      jr nc,.sfx
      ld a,08
      ret
      .sfx
      ld a,(ff00+hMusicVar)
      ret

  # return z iff the current group and room match c and b.
  - compareRoom: |
      ld a,(wActiveGroup)
      cp c
      ret nz
      ld a,(wActiveRoom)
      cp b
      ret

  # returns the byte at e:hl into e.
  - readByte: |
      ld a,(ff00+hRomBank)
      push af
      ld a,e
      ld (ff00+hRomBank),a
      ld (2222),a
      ld e,(hl)
      pop af
      ld (ff00+hRomBank),a
      ld (2222),a
      ret

  # read 2 bytes e:hl into bc.
  - readWord: |
      ld a,(ff00+hRomBank)
      push af
      ld a,e
      ld (ff00+hRomBank),a
      ld (2222),a
      ldi a,(hl)
      ld b,a
      ld a,(hl)
      ld c,a
      pop af
      ld (ff00+hRomBank),a
      ld (2222),a
      ret

  # searches for a value in a table starting at hl, with an entry matching
  # keys b and subkey c, and values e bytes long. sets c if found. a key of
  # ff ends the table.
  - searchDoubleKey: |
      .loop
      ldi a,(hl)
      cp a,ff
      ret z
      cp b
      jr nz,.next
      ldi a,(hl)
      cp c
      jr nz,.done
      scf
      ret
      .next
      inc hl
      .done
      ld a,e
      rst 10
      jr .loop

  # calls lookupCollectMode_body in another bank.
  - lookupCollectMode: |
      push bc
      push de
      push hl
      ld e,06
      ld hl,lookupCollectMode_body
      call interBankCall
      ld a,e
      pop hl
      cp a,ff
      jr nz,.next
      dec hl
      ldi a,(hl)
      .next
      pop de
      pop bc
      ret

  0x02:
  # warp to room under cursor if using tree warp with developer ring.
  - devWarp: |
      ld a,(wActiveRing)
      cp a,DEV_RING
      jr nz,.noWarp
      ld a,(wActiveGroup)
      cp a,02
      jr nc,.noWarp
      or a,80
      ld (wWarpDestGroup),a
      ld a,(wMapMenu_cursorIndex)
      ld (wWarpDestIndex),a
      .noWarp
      ld a,03
      call setMusicVolume
      ret

  # always treat starting seed tree as visited for warping purposes.
  - checkCursorVisited: |
      ld a,(wMapMenu_cursorIndex)
  - checkTreeVisited: |
      cp a,STARTING_TREE_MAP_INDEX
      jp nz,_mapMenu_checkRoomVisited
      or a
      ret

  # treat all rooms on the map as visited when wearing the dev ring.
  - devRingCheckRoomVisited: |
      ld a,(wActiveRing)
      cp a,DEV_RING
      jr nz,.next
      or a
      ret
      .next
      ld a,(hl)
      bit 4,a
      ret

  0x03:
  # allow skipping the capcom screen after one second by pressing start.
  - skipCapcom: |
      push hl
      ld a,(cbb3)
      cp a,94
      jr nc,.noSkip
      call forceEnableIntroInputs
      .noSkip
      pop hl
      jp decHlRef16WithCap

  0x04:
  # look up tiles in custom replacement table after loading a room. the format
  # is (group, room, bitmask, YX, tile ID), with ff ending the table. if the
  # bitmask AND the current room flags is nonzero, the replacement is not made.
  - applyExtraTileSubstitutions: |
      push bc
      push de
      call getThisRoomFlags
      ld e,a
      ld hl,tileSubTable
      ld a,(wActiveGroup)
      ld b,a
      ld a,(wActiveRoom)
      ld c,a
      .loop
      ldi a,(hl)
      cp a,ff
      jr z,.done
      cp b
      jr nz,.groupMismatch
      ldi a,(hl)
      cp c
      jr nz,.roomMismatch
      ldi a,(hl)
      and e
      jr nz,.flagMismatch
      push de
      ld d,cf
      ldi a,(hl)
      ld e,a
      ldi a,(hl)
      ld (de),a
      pop de
      jr .loop
      .groupMismatch
      inc hl
      .roomMismatch
      inc hl
      .flagMismatch
      inc hl
      inc hl
      jr .loop
      .done
      pop de
      pop bc
      call applyAllTileSubstitutions
      ret

  0x05:
  # if wearing dev ring, jump over any tile like a ledge by pressing B with no
  # B item equipped.
  - devJump: |
      push af
      ld a,(wActiveRing)
      cp a,DEV_RING
      jr nz,.next
      ld a,(wInventoryB)
      or a
      jr nz,.next
      ld a,(wKeysPressed)
      and a,02
      jr z,.next
      pop af
      ld a,(w1Link.angle)
      scf
      ret
      .next
      pop af
      ret

  0x06:
  # return a spawning item's collection mode in a and e, based on current room.
  # the table format is (group, room, mode), and modes 80+ are used to index a
  # jump table for special cases. if no match is found, it returns the regular,
  # non-overriden mode.
  - lookupCollectMode_body: |
      ld a,(wActiveGroup)
      ld b,a
      ld a,(wActiveRoom)
      ld c,a
      ld e,01
      ld hl,collectModeTable
      call searchDoubleKey
      ld e,a
      ret nc
      ld a,(hl)
      ld e,a
      cp a,80
      ret c
      ld hl,collectSpecialJumpTable
      and a,7f
      add a,a
      rst 10
      ldi a,(hl)
      ld h,(hl)
      ld l,a
      jp (hl)

  0x15:
  # entries (ID, subID) and indexed by wDungeon Index. these are changed
  # during randomization.
  - bossItemTable: |
      db 00,00
      db 2a,00
      db 2a,00
      db 2a,00
      db 2a,00
      db 2a,00
      db 2a,00
      db 2a,00
      db 2a,00

  # spawn items from bossItemTable in place of boss heart containers.
  - spawnBossItem: |
      push hl
      ld hl,bossItemTable
      ld a,(wDungeonIndex)
      cp a,0c # ages d6 past
      jr nz,.next
      ld a,06
      .next
      rst 18
      ld b,(hl)
      inc hl
      ld c,(hl)
      call createTreasure
      call objectCopyPosition
      pop hl
      ret

  0x3f:
  # use different seed capacity table, so that level zero satchel can still
  # hold 20 seeds.
  - seedCapacityTable: |
      db 20,20,50,99

  # overrides the sprite data loaded for certain interactions. this is mostly
  # used for "non-item" interactions that depict items, like the ones in shops.
  - checkLoadCustomSprite: |
      call _interactionGetData
      push af
      push bc
      push hl
      ld e,41
      ld a,(de)
      ld b,a
      inc e
      ld a,(de)
      ld c,a
      ld e,02
      ld hl,customSpriteJumpTable
      call searchDoubleKey
      jr nc,.done
      ldi a,(hl)
      ld b,a
      ld a,(hl)
      pop hl
      ld h,a
      ld l,b
      pop bc
      jp (hl)
      .done
      pop hl
      pop bc
      pop af
      ret

  # set hl = the address of the sprite for treasure with ID b and subID c.
  # it's usually most convenient to call this through lookupItemSprite or
  # lookupItemSpriteReverse.
  - lookupItemSprite_body: |
      ld e,BANK_TREASURE_DATA
      ld hl,getTreasureDataSprite
      call interBankCall
      ld a,e
      ld hl,interaction60SubidData
      add a,a
      rst 10
      ld a,e
      rst 10
      ret

  # used if item at e:hl is stored in (ID,subID) order.
  - lookupItemSprite: |
      push bc
      call readWord
      call lookupItemSprite_body
      pop bc
      ret

  # used if item at e:hl is stored in (subID,ID) order.
  - lookupItemSpriteReverse: |
      push bc
      call readWord
      ld a,b
      ld b,c
      ld c,a
      call lookupItemSprite_body
      pop bc
      ret

  # copy three bytes at hl to a temporary buffer and set hl = the address of
  # the last byte, with a as its value.
  - copySpriteData: |
      push bc
      push de
      ld b,3
      ld de,cff0
      call copyMemory
      push de
      pop hl
      dec hl
      pop de
      pop bc
      ret

  # override addresses for owl statue text.
  - useOwlText: |
      ld (w7ActiveBank),a
      ld a,(wTextIndexH)
      cp a,3d
      ret nz
      ld hl,owlTextOffsets
      ld a,(wTextIndexL)
      rst 18
      ldi a,(hl)
      ld h,(hl)
      ld l,a
      ld a,BANK_OWL_TEXT
      ld (w7ActiveBank),a
      ret

# some code isn't in the same bank for both games, but it's still the same code
# (addresses aside). such code is defined here so that it can be included by
# the other games' asm files *before* assembly.
#
# the extra indent level here isn't strictly necessary, but it aligns with the
# code in the other banks. also note that freeCode is a map and *not* a list.
freeCode:
  # bank 15 seasons / 16 ages

  # given a treasure id & subid in b & c, if the treasure needs to be upgraded,
  # set hl = the start of the upgraded treasure data + 1 and b = the new
  # treasure ID.
  getUpgradedTreasure: |
      ld a,b
      cp a,TREASURE_SWORD
      jr nz,.notSpinSlash
      ld a,c
      cp a,03
      ld a,b
      ret nc
      .notSpinSlash
      call checkTreasureObtained
      ld c,a
      ld a,b
      ret nc
      cp a,TREASURE_TUNE_OF_ECHOES
      jr nz,.harpDone
      ld a,TREASURE_TUNE_OF_CURRENTS
      ld e,a
      call checkTreasureObtained
      jr nc,.harpDone
      ld b,e
      .harpDone
      push hl
      ld hl,progressiveUpgrades
      ld e,03
      call searchDoubleKey
      jr nc,.done
      ldi a,(hl)
      ld b,a
      ldi a,(hl)
      ld e,(hl)
      pop hl
      ld h,e
      ld l,a
      inc hl
      ret
      .done
      pop hl
      ret

  # set hl = the address of the treasure with ID b and sub ID c, accounting for
  # progressive upgrades. call through getTreasureDataBCE or
  # getTreasureDataSprite!
  getTreasureData_body: |
      ld hl,treasureObjectData
      ld a,b
      add a,a
      rst 10
      ld a,b
      add a,a
      rst 10
      bit 7,(hl)
      jr z,.next
      inc hl
      ldi a,(hl)
      ld h,(hl)
      ld l,a
      .next
      ld a,c
      add a,a
      add a,a
      rst 10
      inc hl
      jp getUpgradedTreasure

  # load fianl treasure ID, param, and text into b, c, and e.
  getTreasureDataBCE: |
      call getTreasureData_body
      ld c,(hl)
      inc hl
      ld e,(hl)
      ret

  # load final treasure sprite into e.
  getTreasureDataSprite: |
      call getTreasureData_body
      inc hl
      inc hl
      ld e,(hl)
      ret

  # return treasure data address and collect mode modified as necessary, given
  # a treasure ID in dx42.
  modifyTreasure: |
      call upgradeTreasure
      call lookupCollectMode
      ld b,a
      swap a
      ret

  # given a treasure at dx40, return hl = the start of the treasure data + 1,
  # accounting for progressive upgrades. also writes the new treasure ID to
  # d070, which is used to set the treasure obtained flag.
  upgradeTreasure: |
      ld e,42
      ld a,(de)
      ld b,a
      inc de
      ld a,(de)
      ld c,a
      call getUpgradedTreasure
      ld e,70
      ld a,b
      ld (de),a
      ret
