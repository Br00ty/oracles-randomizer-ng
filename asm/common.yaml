defines:
  # constants
  AREAFLAG_OUTDOORS: 0x01
  COLLECT_PICKUP_ALT: 0x02
  COLLECT_PICKUP: 0x0a
  COLLECT_POOF: 0x1a
  COLLECT_FALL_KEY: 0x28
  COLLECT_FALL: 0x29
  COLLECT_CHEST: 0x38
  COLLECT_DIVE: 0x49
  COLLECT_CHEST_MAP_OR_COMPASS: 0x68
  SND_CLINK: 0x5a
  SND_ERROR: 0x5a
  SND_SOLVEPUZZLE_2: 0x5b
  TREASURE_SHIELD: 0x01
  TREASURE_SWORD: 0x05
  TREASURE_BOOMERANG: 0x06
  TREASURE_MAGNET_GLOVES: 0x08
  TREASURE_FLUTE: 0x0e
  TREASURE_SEED_SHOOTER: 0x0f
  TREASURE_SLINGSHOT: 0x13
  TREASURE_FEATHER: 0x17
  TREASURE_SEED_SATCHEL: 0x19
  TREASURE_FOOLS_ORE: 0x1e
  TREASURE_GALE_SEEDS: 0x23
  TREASURE_TUNE_OF_ECHOES: 0x25
  TREASURE_TUNE_OF_CURRENTS: 0x26
  TREASURE_RING: 0x2d
  TREASURE_BOSS_KEY: 0x31
  TREASURE_MAKU_SEED: 0x36
  TREASURE_GORON_LETTER: 0x59
  DEV_RING: 0x40

  # hram
  hRomBank: 0x97

  # wram
  wKeysPressed: 0xc481
  wAnimalRegion: 0xc610
  wRingsObtained: 0xc616
  wInventoryB: 0xc688
  wTextIndexL: 0xcba2
  wTextIndexH: 0xcba3
  wMapMenu_mode: 0xcbb3
  wMapMenu_cursorIndex: 0xcbb6
  wInventorySubmenu1CursorPos: 0xcbd1
  wRingMenu_mode: 0xcbd3
  wIsLinkedGame: 0xcc01
  wMenuDisabled: 0xcc02
  wCutsceneTrigger: 0xcc04
  wScreenOffsetY: 0xcd08
  w1Link.angle: 0xd009
  w1Link.yh: 0xd00b
  w7ActiveBank: 0xd0d4

  # rom 00
  interBankCall: 0x008a
  setFlag: 0x020e
  decHlRef16WithCap: 0x0237

  # rom 3f
  _interactionGetData: 0x4437
  giveTreasure_body: 0x44c8

banks:
  0x00:
  # don't play any music. should only be called if the -nomusic flag is
  # given.
  - filterMusic: |
      ld h,a
      cp a,49
      jr nc,.sfx
      ld a,08
      ret
      .sfx
      ld a,(ff00+hMusicVar)
      ret

  # return z iff the current group and room match c and b.
  - compareRoom: |
      ld a,(wActiveGroup)
      cp c
      ret nz
      ld a,(wActiveRoom)
      cp b
      ret

  # returns the byte at e:hl into e.
  - readByte: |
      ld a,(ff00+hRomBank)
      push af
      ld a,e
      ld (ff00+hRomBank),a
      ld (2222),a
      ld e,(hl)
      pop af
      ld (ff00+hRomBank),a
      ld (2222),a
      ret

  # read 2 bytes e:hl into bc.
  - readWord: |
      ld a,(ff00+hRomBank)
      push af
      ld a,e
      ld (ff00+hRomBank),a
      ld (2222),a
      ldi a,(hl)
      ld b,a
      ld a,(hl)
      ld c,a
      pop af
      ld (ff00+hRomBank),a
      ld (2222),a
      ret

  # searches for a value in a table starting at hl, with an entry matching
  # keys b and subkey c, and values e bytes long. sets c if found. a key of
  # ff ends the table.
  - searchDoubleKey: |
      .loop
      ldi a,(hl)
      cp a,ff
      ret z
      cp b
      jr nz,.next
      ldi a,(hl)
      cp c
      jr nz,.done
      scf
      ret
      .next
      inc hl
      .done
      ld a,e
      rst 10
      jr .loop

  # calls lookupCollectMode_body in another bank.
  - lookupCollectMode: |
      push bc
      push de
      push hl
      ld e,06
      ld hl,lookupCollectMode_body
      call interBankCall
      ld a,e
      pop hl
      cp a,ff
      jr nz,.next
      dec hl
      ldi a,(hl)
      .next
      pop de
      pop bc
      ret

  # return item ID and subID for a small key drop in group b, room c.
  - lookupKeyDrop: |
      push de
      push hl
      ld e,BANK_SMALL_KEY_DROPS
      ld hl,lookupKeyDrop_body
      call interBankCall
      pop hl
      pop de
      ret

  0x02:
  # warp to room under cursor if using tree warp with developer ring.
  - devWarp: |
      ld a,(wActiveRing)
      cp a,DEV_RING
      jr nz,.noWarp
      ld a,(wActiveGroup)
      cp a,02
      jr nc,.noWarp
      or a,80
      ld (wWarpDestGroup),a
      ld a,(wMapMenu_cursorIndex)
      ld (wWarpDestIndex),a
      .noWarp
      ld a,03
      call setMusicVolume
      ret

  # allow ring list to be accessed through the ring box icon.
  - openRingList: |
      ld a,(wInventorySubmenu1CursorPos)
      cp a,0f
      ret nz
      ld a,81
      ld (wRingMenu_mode),a
      ld a,04
      call openMenu
      pop hl
      ret

  # auto-equip rings when selected in ring list.
  - autoEquipRing: |
      call _ringMenu_updateSelectedRingFromList
      ld (wActiveRing),a
      ret

  # don't save gfx when opening ring list from subscreen (they were already
  # saved when opening the item menu), and clear screen scroll variables (which
  # are saved anyway).
  - ringListGfxFix: |
      call setMusicVolume
      ld a,(wRingMenu_mode)
      bit 7,a
      ret z
      and a,7f
      ld (wRingMenu_mode),a
      xor a
      ld (ff00+hCameraY),a
      ld (ff00+hCameraX),a
      ld hl,wScreenOffsetY
      ldi (hl),a
      ldi (hl),a
      jp clearMenu

  # always treat starting seed tree as visited for warping purposes.
  - checkCursorVisited: |
      ld a,(wMapMenu_cursorIndex)
  - checkTreeVisited: |
      cp a,STARTING_TREE_MAP_INDEX
      jp nz,_mapMenu_checkRoomVisited
      or a
      ret

  0x03:
  # allow skipping the capcom screen after one second by pressing start.
  - skipCapcom: |
      push hl
      ld a,(cbb3)
      cp a,94
      jr nc,.noSkip
      call forceEnableIntroInputs
      .noSkip
      pop hl
      jp decHlRef16WithCap

  0x04:
  # look up tiles in custom replacement table after loading a room. the format
  # is (group, room, bitmask, YX, tile ID), with ff ending the table. if the
  # bitmask AND the current room flags is nonzero, the replacement is not made.
  - applyExtraTileSubstitutions: |
      push bc
      push de
      call getThisRoomFlags
      ld e,a
      ld hl,tileSubTable
      ld a,(wActiveGroup)
      ld b,a
      ld a,(wActiveRoom)
      ld c,a
      .loop
      ldi a,(hl)
      cp a,ff
      jr z,.done
      cp b
      jr nz,.groupMismatch
      ldi a,(hl)
      cp c
      jr nz,.roomMismatch
      ldi a,(hl)
      and e
      jr nz,.flagMismatch
      push de
      ld d,cf
      ldi a,(hl)
      ld e,a
      ldi a,(hl)
      ld (de),a
      pop de
      jr .loop
      .groupMismatch
      inc hl
      .roomMismatch
      inc hl
      .flagMismatch
      inc hl
      inc hl
      jr .loop
      .done
      pop de
      pop bc
      call applyAllTileSubstitutions
      ret

  0x05:
  # if wearing dev ring, jump over any tile like a ledge by pressing B with no
  # B item equipped.
  - devJump: |
      push af
      ld a,(wActiveRing)
      cp a,DEV_RING
      jr nz,.next
      ld a,(wInventoryB)
      or a
      jr nz,.next
      ld a,(wKeysPressed)
      and a,02
      jr z,.next
      pop af
      ld a,(w1Link.angle)
      scf
      ret
      .next
      pop af
      ret

  0x06:
  # return a spawning item's collection mode in a and e, based on current room.
  # the table format is (group, room, mode), and modes 80+ are used to index a
  # jump table for special cases. if no match is found, it returns the regular,
  # non-overriden mode.
  - lookupCollectMode_body: |
      ld a,(wActiveGroup)
      ld b,a
      ld a,(wActiveRoom)
      ld c,a
      ld e,01
      ld hl,collectModeTable
      call searchDoubleKey
      ld e,a
      ret nc
      ld a,(hl)
      ld e,a
      cp a,80
      ret c
      ld hl,collectSpecialJumpTable
      and a,7f
      add a,a
      rst 10
      ldi a,(hl)
      ld h,(hl)
      ld l,a
      jp (hl)

  0x15:
  # entries (ID, subID) and indexed by wDungeon Index. these are changed
  # during randomization.
  - bossItemTable: |
      db 00,00
      db 2a,00
      db 2a,00
      db 2a,00
      db 2a,00
      db 2a,00
      db 2a,00
      db 2a,00
      db 2a,00

  # spawn items from bossItemTable in place of boss heart containers.
  - spawnBossItem: |
      push hl
      ld hl,bossItemTable
      ld a,(wDungeonIndex)
      cp a,0c # ages d6 past
      jr nz,.next
      ld a,06
      .next
      rst 18
      ld b,(hl)
      inc hl
      ld c,(hl)
      call createTreasure
      call objectCopyPosition
      pop hl
      ret

  0x3f:
  # put obtained rings directly into ring list (no need for appraisal), and
  # tell the player what type of ring it is.
  - autoAppraiseRing: |
      ld hl,wRingsObtained
      ld a,c
      and a,3f
      call setFlag
      ld a,c
      add a,40
      ld (cbb1),a # part of wTextSubstitutions
      ld bc,301c
      call showText
      ret

  # use different seed capacity table, so that level zero satchel can still
  # hold 20 seeds.
  - seedCapacityTable: |
      db 20,20,50,99

  # overrides the sprite data loaded for certain interactions. this is mostly
  # used for "non-item" interactions that depict items, like the ones in shops.
  - checkLoadCustomSprite: |
      call _interactionGetData
      push af
      push bc
      push hl
      ld e,41
      ld a,(de)
      ld b,a
      inc e
      ld a,(de)
      ld c,a
      ld e,02
      ld hl,customSpriteJumpTable
      call searchDoubleKey
      jr nc,.done
      ldi a,(hl)
      ld b,a
      ld a,(hl)
      pop hl
      ld h,a
      ld l,b
      pop bc
      jp (hl)
      .done
      pop hl
      pop bc
      pop af
      ret

  # set hl = the address of the sprite for treasure with ID b and subID c.
  # it's usually most convenient to call this through lookupItemSprite or
  # lookupItemSpriteReverse.
  - lookupItemSprite_body: |
      ld e,BANK_TREASURE_DATA
      ld hl,getTreasureDataSprite
      call interBankCall
      ld a,e
      ld hl,interaction60SubidData
      add a,a
      rst 10
      ld a,e
      rst 10
      ret

  # used if item at e:hl is stored in (ID,subID) order.
  - lookupItemSprite: |
      push bc
      call readWord
      call lookupItemSprite_body
      pop bc
      ret

  # used if item at e:hl is stored in (subID,ID) order.
  - lookupItemSpriteReverse: |
      push bc
      call readWord
      ld a,b
      ld b,c
      ld c,a
      call lookupItemSprite_body
      pop bc
      ret

  # copy three bytes at hl to a temporary buffer and set hl = the address of
  # the last byte, with a as its value.
  - copySpriteData: |
      push bc
      push de
      ld b,3
      ld de,cff0
      call copyMemory
      push de
      pop hl
      dec hl
      pop de
      pop bc
      ret

  # override addresses for owl statue text.
  - useOwlText: |
      ld (w7ActiveBank),a
      ld a,(wTextIndexH)
      cp a,3d
      ret nz
      ld hl,owlTextOffsets
      ld a,(wTextIndexL)
      rst 18
      ldi a,(hl)
      ld h,(hl)
      ld l,a
      ld a,BANK_OWL_TEXT
      ld (w7ActiveBank),a
      ret

# some code isn't in the same bank for both games, but it's still the same code
# (addresses aside). such code is defined here so that it can be included by
# the other games' asm files *before* assembly.
#
# the extra indent level here isn't strictly necessary, but it aligns with the
# code in the other banks. also note that freeCode is a map and *not* a list.
freeCode:
  # bank 15 seasons / 16 ages

  # given a treasure ID in b, if the treasure needs to be upgraded, set hl =
  # the start of the upgraded treasure data + 1 and b = the new treasure ID.
  getUpgradedTreasure: |
      ld a,b
      call checkTreasureObtained
      ld c,a
      ld a,b
      ret nc
      cp a,TREASURE_TUNE_OF_ECHOES
      jr nz,.harpDone
      ld a,TREASURE_TUNE_OF_CURRENTS
      ld e,a
      call checkTreasureObtained
      jr nc,.harpDone
      ld b,e
      .harpDone
      push hl
      ld hl,progressiveUpgrades
      ld e,03
      call searchDoubleKey
      jr nc,.done
      ldi a,(hl)
      ld b,a
      ldi a,(hl)
      ld e,(hl)
      pop hl
      ld h,e
      ld l,a
      inc hl
      ret
      .done
      pop hl
      ret

  # set hl = the address of the treasure with ID b and sub ID c, accounting for
  # progressive upgrades. call through getTreasureDataBCE or
  # getTreasureDataSprite!
  getTreasureData_body: |
      ld hl,treasureObjectData
      ld a,b
      add a,a
      rst 10
      ld a,b
      add a,a
      rst 10
      bit 7,(hl)
      jr z,.next
      inc hl
      ldi a,(hl)
      ld h,(hl)
      ld l,a
      .next
      ld a,c
      add a,a
      add a,a
      rst 10
      inc hl
      jp getUpgradedTreasure

  # load fianl treasure ID, param, and text into b, c, and e.
  getTreasureDataBCE: |
      call getTreasureData_body
      ld c,(hl)
      inc hl
      ld e,(hl)
      ret

  # load final treasure sprite into e.
  getTreasureDataSprite: |
      call getTreasureData_body
      inc hl
      inc hl
      ld e,(hl)
      ret

  # return treasure data address and collect mode modified as necessary, given
  # a treasure ID in dx42.
  modifyTreasure: |
      call upgradeTreasure
      call lookupCollectMode
      ld b,a
      swap a
      ret

  # given a treasure ID in dx42, return hl = the start of the treasure data
  # + 1, accounting for progressive upgrades. also writes the new treasure
  # ID to d070, which is used to set the treasure obtained flag.
  upgradeTreasure: |
      ld e,42
      ld a,(de)
      ld b,a
      call getUpgradedTreasure
      ld e,70
      ld a,b
      ld (de),a
      ret

  lookupKeyDrop_body: |
      push bc
      ld a,(wActiveGroup)
      ld b,a
      ld a,(wActiveRoom)
      ld c,a
      ld hl,smallKeyDrops
      ld e,02
      call searchDoubleKey
      pop bc
      ret nc
      ld b,(hl)
      inc hl
      ld c,(hl)
      ret
